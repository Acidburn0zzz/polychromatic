#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015-2018 Luke Horwell <code@horwell.me>
#               2015-2016 Terry Cain <terry@terrys-home.co.uk>

"""
Polychromatic GUI for interfacing with the OpenRazer's Python Library and daemon
"""

import argparse
import gettext
import glob
import os
import re
import signal
import sys
import threading
import time
from setproctitle import setproctitle
from subprocess import Popen as background_process
from subprocess import check_output
from platform import linux_distribution

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
gi.require_version("WebKit2", "4.0")
from gi.repository import GLib, Gtk, Gdk, WebKit2

try:
    import openrazer.client as rclient
    daemon_missing = False
except ImportError as e:
    # We'll show a graphical error when loading up.
    print("Failed to import modules for daemon.")
    print("Exception: " + str(e))
    daemon_missing = True

try:
    # Relative (for development)
    import pylib.preferences as pref
    import pylib.profiles as prof
    import pylib.common as common
    dev_version = True
except ImportError:
    # Installed to system
    import polychromatic.preferences as pref
    import polychromatic.profiles as prof
    import polychromatic.common as common
    dev_version = False
except Exception as e:
    print("One or more of Polychromatic's modules could not be imported!")
    print("Try re-installing the application.")
    print("\nException:" + str(e))
    exit(1)

setproctitle("polychromatic-controller")
version = "0.4.0-alpha"

path = pref.Paths()
path.data_source = path.get_data_source(__file__)
daemon_config_path = os.path.join(os.path.expanduser("~"), ".local/share/openrazer/razer.conf")

# Imported on-demand:
#   * requests
#   * configparser
#   * shutil
#   * grp

if dev_version:
    version = version + "-dev"
    dbg = common.Debugging()

    # Compile styling when working locally.
    dbg.stdout("Compiling Styling...", dbg.action)
    os.system(os.path.join(path.data_source, "../tools/build-sass.sh"))

    if not os.path.exists(os.path.join(path.data_source, "ui/css/default.css")):
        dbg.stdout("Failed to start due to missing styling.", dbg.error)
        exit(1)
else:
    version = version + "-stable"


def get_string_bank(_):
    return {
        "debug1": "Hello World",
        "debug2": "Test String"
    }


class AppView(WebKit2.WebView):
    def __init__(self):
        """
        WebKit2 provides the user interface using web technologies.
        """
        webkit = WebKit2
        webkit.WebView.__init__(self)
        self.set_background_color(Gdk.RGBA(0, 0, 0, 1))

        # Post-actions after pages fully load.
        self.connect("load-changed", self.load_changed_cb)
        self.connect("notify::title", self.title_changed_cb)
        self.connect("context-menu", self.context_menu_cb)

        try:
            # Allows local SVG files to load.
            self.get_settings().set_allow_file_access_from_file_urls(True)
            try:
                self.get_settings().set_allow_universal_access_from_file_urls(True)
            except AttributeError:
                dbg.stdout("Ignoring set_allow_universal_access_from_file_urls because the WebKit2GTK version is <2.14.", dbg.warning, 1)

            # Print console log errors to stdout if verbose
            if dbg.verbose_level >= 1:
                self.get_settings().set_enable_write_console_messages_to_stdout(True)

            # Basic accessibility - keyboard navigation
            self.get_settings().set_enable_spatial_navigation(True)
            self.get_settings().set_enable_caret_browsing(True)

        except AttributeError as e:
            dbg.stdout("WebKit2GTK failed to initialise!", dbg.error)
            print("Your distribution may be using an older version of this library.")
            print("For example, Debian/Ubuntu provides this in 'gir1.2-webkit-4.0'\n")
            dbg.stdout("The exception was: {0}\n".format(str(e)), dbg.error)
            exit(1)

        # Enable web inspector for debugging
        if dbg.verbose_level == 3:
            self.get_settings().set_property("enable-developer-extras", True)
            inspector = self.get_inspector()
            inspector.show()

        # Load the base page structure
        self.load_uri("file://" + os.path.join(path.data_source, "ui/controller.html"))
        dbg.stdout("WebView Initialised", dbg.success, 1)

    def run_js(self, function):
        """
        Runs a JavaScript function on the page, regardless of which thread it is called from.
        GTK+ operations must be performed on the same thread to prevent crashes.
        """
        GLib.idle_add(self._run_js, function)

    def _run_js(self, function):
        """
        Private function for running a JavaScript function on the page when invoked from run_js()
        """
        self.run_javascript(function)
        return GLib.SOURCE_REMOVE

    def title_changed_cb(self, view, frame):
        """
        Callback: Title changed

        This is where the frontend has set document.title, which is used for
        communicating to Python via commands.
        """
        title = self.get_title()
        if title not in ["null", None, "", " "]:
            app.process_command(title)

    def context_menu_cb(self, view, menu, event, htr, user_data=None):
        """
        Callback: Disables the context menu.
        """
        return True

    def load_changed_cb(self, view, frame):
        """
        Callback: Page changed

        Intended to be called when the initial controller.html page has finished loading.
        """
        dbg.stdout("WebView still loading...", dbg.debug, 2)
        if not self.is_loading():
            dbg.stdout("WebView Ready.", dbg.success, 1)
            thread = threading.Thread(target=app.start_loading, args=([view]))
            thread.start()


class AppWindow(object):
    def run(self):
        """
        Assembles the main application window.
        """
        self.webkit = AppView()
        self.window = Gtk.Window(title=_("Polychromatic Controller"))
        self.window.set_wmclass("polychromatic-controller", "polychromatic-controller")
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.modify_bg(Gtk.StateType(0), Gdk.Color(0, 0, 0))
        self.window.set_size_request(1000, 600)

        try:
            self.window.set_icon_from_file(os.path.join(path.data_source, "ui/img/general/controller.svg"))
        except:
            dbg.stdout("Failed to set window icon.", dbg.warning, 2)

        # Add elements to window
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw.add(self.webkit)

        # Compatibility option if DEs don't scale to HIDPI displays automatically.
        scale2x = float(pref.get("editor", "scale2x", False))
        if scale2x == True:
            self.webkit.set_zoom_level(1.5)
            self.window.set_size_request(1500, 900)
            dbg.stdout("HIDPI compatibility enabled", dbg.action, 1)

        # Build an auto expanding box and add the scrolled window
        b = Gtk.VBox(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)
        self.window.add(b)
        self.window.connect("delete-event", Gtk.main_quit)
        self.window.show_all()
        dbg.stdout("Window Initialised", dbg.success, 1)

        # Kills process when CTRL+C'd.
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()


class Controller(object):
    def __init__(self):
        """
        The main application runtime. Responsive for populating the UI and user interaction logic.
        """
        # Variables are assigned later in start_loading()
        self.webkit = None
        self.devman = None
        self.devices = []

    def run_javascript(self, function):
        """
        Sends a JavaScript function to the page.
        """
        self.webkit.run_js(function)

    def update_page(self, element, function, parm1=None, parm2=None):
        """
        Sends a jQuery function to the page, ensuring correctly parsed quotes.
        """
        if parm1 and parm2:
            buffer = '$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')"
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)
        if parm1:
            buffer = '$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')"
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)
        else:
            buffer = '$("' + element + '").' + function + '()'
            dbg.stdout(' => ' + buffer, dbg.debug, 2)
            self.run_javascript(buffer)

    def update_content_view(self, section_name, target_element="content"):
        """
        Loads a HTML 'section' into the content view parsing string placeholders.
        """
        dbg.stdout("Loading content view: " + section_name, dbg.debug, 1)
        with open(os.path.join(path.data_source, "ui/sections/" + section_name + ".html")) as f:
            html = f.read().replace('\n', '')

        # Process strings
        content_strings = re.findall(r"\[\[(.*?)\]\]",html)
        for string in content_strings:
            try:
                html = html.replace("[[" + string + "]]", string_bank[string.strip()])
            except KeyError:
                dbg.stdout("Missing '{0}' string in section '{1}'".format(string.strip(), section_name), dbg.error)

        dbg.stdout("Loaded content view: {0} ({1} strings)".format(section_name, len(content_strings)), dbg.debug, 1)
        self.update_page(target_element, "html", html)

    def process_command(self, cmd):
        """
        Process a command issued from the frontend for the page.
        """
        if cmd == "null":
            return

        dbg.stdout("=> Command: " + str(cmd), dbg.debug, 2)

        # Global commands
        if cmd == "quit":
             # Close the application.
            exit()

        elif cmd == "restart-daemon":
            # Restarts the OpenRazer daemon.
            restart_daemon_service()

        elif cmd == "reload":
            # Restarts the application.
            os.execv(__file__, sys.argv)

        elif cmd.startswith("run?"):
            # Runs a program (or command) to run in the background.
            # Expects:    ?<program>
            background_process(cmd.split("run?")[1], shell=True)

        elif cmd.startswith("open?"):
            # Opens a file/folder/protocol using the default application.
            # Expects:    ?<path>
            os.system("xdg-open '{0}'".format(cmd.split("open?")[1]))

        elif cmd.startswith("browse?"):
            # Opens the Browse dialogue and sets the path to a textbox.
            # Expects:    ?<browse_id>?<target element id>
            cmd = cmd.split("?")
            browse_id = int(cmd[1])
            target_element = cmd[2]

            dbg.stdout("Opening file picker: " + str(browse_id), dbg.action, 1)
            picker = Dialogues.file_picker(browse_id)
            if picker != None:
                dbg.stdout("Picked file: " + picker, dbg.success, 1)
                self.update_page("#" + target_element, "val", picker)
            else:
                dbg.stdout("File browser was closed without picking a file", dbg.warning, 1)
                return

        # Special
        elif cmd == "pref-reset-all":
            # Completely nukes save data stored by Polychromatic.
            dbg.stdout("Erasing ~/.config/polychromatic/ ...", dbg.action)
            pref.clear_config()
            dbg.stdout("Application will restart.", dbg.action)
            os.execv(__file__, sys.argv)

        # Colours
        elif cmd.startswith("colour-pick?"):
            # Opens the colour picker to choose a colour for an element.
            # Expects:    ?<element id>?
            cmd = cmd.split("?")
            element_id = "#" + cmd[1] + "-preview"
            dbg.stdout("Opening colour picker", dbg.action, 1)
            picker = Dialogues.color_picker()

            if picker:
                dbg.stdout("Selected colour RGB " + picker, dbg.success, 1)
                self.update_page(element_id, "css", "background-color", "rgb({0})".format(picker))
            else:
                dbg.stdout("Cancelled colour picker dialogue window.", dbg.action, 1)

        # Commands specific to current page
        else:
            if not self.screen.process_command(cmd):
                dbg.stdout("Unimplemented command: " + cmd, dbg.error)

        # WebKit2 quirk - clear "title" so same command can execute again
        self.run_javascript("cmd('null')");

    def start_loading(self, webkit):
        """
        Function that triggers the main application's operations.
        """
        self.webkit = webkit
        dbg.stdout("Version " + version, dbg.debug, 1)

        self.update_content_view("ui-test")

        dbg.stdout("Application Ready.", dbg.success, 1)

    def device_state_changed():
        pass


class Dialogues():
    def color_picker():
        # TODO: Ability to track and set last colour in GTK dialog.
        colorseldlg = Gtk.ColorSelectionDialog(_("Choose a Color"))
        colorsel = colorseldlg.get_color_selection()

        if colorseldlg.run() == Gtk.ResponseType.OK:
            colour = colorsel.get_current_color()
            red = int(colour.red / 256)
            green = int(colour.green / 256)
            blue = int(colour.blue / 256)
            colorseldlg.destroy()
            return "{0},{1},{2}".format(str(red), str(green), str(blue))
        else:
            colorseldlg.destroy()
            return None

    def file_picker(browse_id):
        """
        Opens a file picker and returns the string (if result is OK)

        Expects:
            browse_id       An integer that determines the settings for the dialog.

        Browse IDs:
        1       Choose icon for tray applet

        """

        if browse_id == 1:
            help_text = _("Choose an icon to use for the tray applet.")
            filter_mode = "image"
        else:
            dbg.stdout("Unimplemented file picker!", dbg.error, 1)
            return

        win = Gtk.Window(title=_("Polychromatic Controller"))
        dialog = Gtk.FileChooserDialog(help_text, win, Gtk.FileChooserAction.OPEN, \
                                       (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, \
                                        Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
        # Setup filters
        if filter_mode == "image":
            a = Gtk.FileFilter()
            a.set_name(_("All Images"))
            a.add_mime_type("image/jpeg")
            a.add_mime_type("image/png")
            a.add_mime_type("image/gif")
            a.add_mime_type("image/svg+xml")
            dialog.add_filter(a)

            j = Gtk.FileFilter()
            j.set_name("JPEG " + _("Image"))
            j.add_mime_type("image/jpeg")
            dialog.add_filter(j)

            p = Gtk.FileFilter()
            p.set_name("PNG " + _("Image"))
            p.add_mime_type("image/png")
            dialog.add_filter(p)

            g = Gtk.FileFilter()
            g.set_name("GIF " + _("Image"))
            g.add_mime_type("image/gif")
            dialog.add_filter(g)

            s = Gtk.FileFilter()
            s.set_name("SVG " + _("Image"))
            s.add_mime_type("image/svg+xml")
            dialog.add_filter(s)

        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            filename = dialog.get_filename()
            dialog.destroy()
            return filename
        else:
            dialog.destroy()
            return None


def parse_parameters():
    global _
    parser = argparse.ArgumentParser(add_help=False)
    parser._optionals.title = _("Optional arguments")
    parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
    parser.add_argument("--version", help=_("Print progran version and exit"), action="store_true")
    parser.add_argument("-v", "--verbose", help=_("Be verbose to stdout"), action="store_true")
    parser.add_argument("-vv", "-d", "--debug", help=_("Be very verbose (for debugging)"), action="store_true")
    parser.add_argument("--print-device-info", help=_("Gets a list of capabilities for a device"), action="store_true")
    parser.add_argument("--locale", help=_("Force a specific locale, e.g. de_DE"), action="store")

    # For front-end debugging (developer tools)
    parser.add_argument("--inspect", help=argparse.SUPPRESS, action="store_true")

    args = parser.parse_args()

    if args.version:
        print("Polychromatic v" + version)
        exit(0)

    if args.verbose:
        dbg.verbose_level = 1
        dbg.stdout(_("Verbose Enabled"), dbg.action, 1)

    if args.debug:
        dbg.verbose_level = 2
        dbg.stdout(_("Debug Verbose Enabled"), dbg.action, 2)

    if args.print_device_info:
        CommandLineOnly.print_device_capability_info()

    if args.inspect:
        dbg.verbose_level = 3

    if args.locale:
        _ = common.setup_translations(__file__, "polychromatic", args.locale)


def restart_tray_applet():
    print("Tray applet restarting...")
    try:
        pid = int(check_output(["pidof", "polychromatic-tray-applet"]))
        os.kill(pid, 9)
    except Exception:
        print("Tray applet is not running so not relaunching.")
        return

    # Where is the tray applet?
    if __file__.startswith("/usr"):
        tray_bin_path = "/usr/bin/polychromatic-tray-applet"
    else:
        tray_bin_path = os.path.abspath(os.path.join(path.data_source, "../polychromatic-tray-applet"))

    # Attempt to gracefully stop the process, then launch again.
    try:
        background_process(tray_bin_path)
    except OSError:
        print("Tray applet failed to relaunch.")
        return

    print("Tray applet reloaded.")


def restart_daemon_service():
    from subprocess import check_output
    from shutil import which

    # Enough time to load "loading" page
    time.sleep(0.5)

    # Is the daemon actually installed?
    if not which("openrazer-daemon"):
        app.load_lock = False
        show_fatal_error(108)
        return

    # Gracefully stop the daemon
    print("Stopping openrazer-daemon.", end='')
    app.update_page("#status-text", "html", _("Stopping daemon..."))
    try:
        app.devman.stop_daemon()
    except Exception as NoneType:
        # Cannot stop gracefully. Skip this.
        pass

    # Wait for the daemon to stop.
    stopped = False
    app.update_page(".progress", "fadeIn", "fast")
    app.update_page(".progress-inner", "addClass", "increasing")

    for x in range(0, 5):
        print(".", end='')
        try:
            daemon_pid = int(check_output(["pidof", "openrazer-daemon"]))
        except:
            stopped = True
            break
        time.sleep(1)

    app.update_page(".progress", "fadeOut", "fast")
    app.update_page(".progress-inner", "removeClass", "increasing")

    # Kill the daemon if still not ended
    if not stopped:
        print("\nKilling openrazer-daemon...")
        app.update_page("#status-text", "html", _("Killing daemon process..."))
        os.kill(daemon_pid, 9)

    # Ensure a clean log
    print("\nArchiving log...")
    app.update_page("#status-text", "html", _("Archiving log..."))
    log_path = os.path.join(os.path.expanduser("~"), ".local/share/openrazer/razer.log")
    log_bak = os.path.join(os.path.expanduser("~"), ".local/share/openrazer/razer.log.bak")
    if os.path.exists(log_path):
        os.rename(log_path, log_bak)

    # Wait for daemon to start again
    time.sleep(1)
    print("\nStarting openrazer-daemon...")
    app.update_page("#status-text", "html", _("Starting daemon..."))
    background_process("openrazer-daemon", shell=True)

    # Check the process is running
    print("Waiting for openrazer-daemon to start...")
    app.update_page(".progress", "fadeIn", "fast")
    app.update_page(".progress-inner", "addClass", "increasing")
    for x in range(0, 5):
        print(".", end='')
        try:
            daemon_pid = int(check_output(["pidof", "openrazer-daemon"]))
            running = True
            break
        except:
            running = False
        time.sleep(1)

    if not running:
        app.load_lock = False
        show_fatal_error(109)
        return

    # Relaunch Controller / Tray Applet
    print("Relaunching Polychromatic...")
    app.update_page(".progress", "fadeOut", "fast")
    app.update_page("#loading", "fadeOut", "fast")
    app.update_page("#status-text", "fadeOut", "fast")
    restart_tray_applet()
    os.execv(__file__, sys.argv)


# For restarting the tray applet (only when running)
tray_pid_file = os.path.join("/run/user/", str(os.getuid()), "polychromatic-tray-applet.pid")

if __name__ == "__main__":
    _ = common.setup_translations(__file__, "polychromatic")
    string_bank = get_string_bank(_)
    dbg = common.Debugging()
    parse_parameters()
    win = AppWindow()
    app = Controller()
    win.run()
